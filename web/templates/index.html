<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>EDU-CPU CTF</title>
<style>
:root {
  --bg:        #0a0e17;
  --panel:     #111827;
  --panel-alt: #151d2e;
  --border:    #1e2d4a;
  --text:      #c9cdd5;
  --text-dim:  #5a6484;
  --accent:    #00e676;
  --accent-dim:#00b35f;
  --error:     #ff4757;
  --error-bg:  #2a1019;
  --highlight: #182238;
  --mono: 'JetBrains Mono','Fira Code','Cascadia Code','Consolas','Courier New',monospace;
}
*{margin:0;padding:0;box-sizing:border-box}
html{font-size:14px}
body{
  background:var(--bg);color:var(--text);
  font-family:var(--mono);
  min-height:100vh;
  display:flex;flex-direction:column;align-items:center;
  padding:1.5rem 1rem;
}
a{color:var(--accent)}
h1{
  font-size:1.6rem;letter-spacing:.08em;
  color:var(--accent);text-transform:uppercase;
  margin-bottom:.25rem;
}
.subtitle{color:var(--text-dim);font-size:.85rem;margin-bottom:1.5rem}

.container{width:100%;max-width:1100px}

/* ---------- panels ---------- */
.panel{
  background:var(--panel);border:1px solid var(--border);
  border-radius:6px;margin-bottom:1rem;overflow:hidden;
}
.panel-header{
  display:flex;align-items:center;justify-content:space-between;
  padding:.5rem .75rem;background:var(--panel-alt);
  border-bottom:1px solid var(--border);font-size:.8rem;
  color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;
  user-select:none;
}
.panel-body{padding:0}
textarea,.output{
  display:block;width:100%;background:transparent;color:var(--text);
  border:none;outline:none;resize:vertical;padding:.75rem;
  font-family:var(--mono);font-size:.85rem;line-height:1.6;
  tab-size:4;
}
textarea{min-height:520px}
.output{
  min-height:120px;max-height:400px;overflow:auto;
  resize:vertical;white-space:pre;
}
.output.stdout{color:#a0f0c0}
.output.stderr{color:#ffa64d}

/* ---------- controls ---------- */
.controls{
  display:flex;align-items:center;gap:1rem;
  margin-bottom:1rem;flex-wrap:wrap;
}
button{
  background:var(--accent);color:#0a0e17;
  border:none;border-radius:4px;padding:.5rem 1.5rem;
  font-family:var(--mono);font-size:.85rem;font-weight:700;
  cursor:pointer;letter-spacing:.04em;text-transform:uppercase;
  transition:background .15s;
}
button:hover{background:var(--accent-dim)}
button:disabled{opacity:.5;cursor:not-allowed}
label.check{
  display:flex;align-items:center;gap:.4rem;
  color:var(--text-dim);cursor:pointer;font-size:.85rem;
}
label.check input{accent-color:var(--accent)}
.status{font-size:.8rem;color:var(--text-dim)}
.status.ok{color:var(--accent)}
.status.err{color:var(--error)}

/* ---------- errors ---------- */
.errors{
  background:var(--error-bg);border:1px solid #4a1020;
  border-radius:6px;padding:.75rem;margin-bottom:1rem;
  color:var(--error);font-size:.82rem;line-height:1.6;
  display:none;white-space:pre-wrap;
}
.errors.visible{display:block}

/* ---------- output grid ---------- */
.output-row{
  display:grid;grid-template-columns:1fr 1fr;gap:1rem;
}
@media(max-width:700px){
  .output-row{grid-template-columns:1fr}
}

/* ---------- ISA reference ---------- */
.ref-toggle{
  background:none;border:1px solid var(--border);color:var(--text-dim);
  border-radius:4px;padding:.3rem .8rem;font-size:.75rem;
  cursor:pointer;text-transform:uppercase;letter-spacing:.04em;
  margin-bottom:1rem;
}
.ref-toggle:hover{border-color:var(--accent);color:var(--accent);background:none}
.ref{
  display:none;background:var(--panel);border:1px solid var(--border);
  border-radius:6px;padding:1rem;margin-bottom:1rem;
  font-size:.78rem;line-height:1.65;color:var(--text-dim);
  column-count:2;column-gap:2rem;
}
.ref.visible{display:block}
.ref section{break-inside:avoid;margin-bottom:.3rem}
.ref h3{color:var(--accent);font-size:.82rem;margin:.6rem 0 .2rem;break-after:avoid}
.ref h3:first-child{margin-top:0}
.ref p{margin:.2rem 0}
.ref code{color:var(--text)}
.ref pre{
  background:var(--bg);border:1px solid var(--border);
  border-radius:4px;padding:.4rem .6rem;margin:.3rem 0 .2rem;
  color:var(--text);overflow-x:auto;white-space:pre;
  font-size:.75rem;line-height:1.5;
}
@media(max-width:700px){.ref{column-count:1}}
</style>
</head>
<body>

<div class="container">
  <h1>EDU-CPU CTF</h1>
  <p class="subtitle">
    Write an assembly routine for the EDU-CPU 8-bit processor.
    Your code is loaded at address 0x00. There is something interesting
    hidden elsewhere in memory. Output is the byte written to address 0xFF.
  </p>

  <!-- ISA Quick Reference -->
  <button class="ref-toggle" onclick="document.getElementById('ref').classList.toggle('visible')">
    ISA Quick Reference
  </button>
  <div class="ref" id="ref">
    <section>
      <h3>Registers</h3>
      <p><code>A</code> — the accumulator, implicit destination for all ALU operations.
      <code>R0</code>, <code>R1</code> — general-purpose registers.
      All are 8-bit (values 0–255). A 4-entry hardware stack supports
      <code>PUSH</code>/<code>POP</code> and <code>CALL</code>/<code>RET</code>.</p>
    </section>

    <section>
      <h3>Load &amp; Store</h3>
      <p>Two-operand syntax. <code>LD</code> copies a value <em>into</em> a register.
      <code>ST</code> copies a register value <em>out</em> to a destination.
      Works with <code>A</code>, <code>R0</code>, and <code>R1</code>.
      Neither instruction affects flags.</p>
<pre>LD  A, #42       ; A ← immediate value 42
LD  R0, A        ; R0 ← copy of A (register mode)
LD  A, [0x80]    ; A ← contents of memory[0x80]
LD  A, [R0+3]    ; A ← memory[R0 + 3] (indexed)
ST  A, [0xFF]    ; memory[0xFF] ← A (output port)
ST  R1, [R0+0]   ; memory[R0] ← R1</pre>
    </section>

    <section>
      <h3>Addressing Modes</h3>
      <p>Every LD, ST, and ALU instruction can use one of four modes:</p>
      <p><code>#val</code> — <strong>immediate</strong>: the value is encoded in the instruction itself.<br>
      <code>Rn</code> — <strong>register</strong>: the value comes from another register (1-byte instruction, no operand).<br>
      <code>[addr]</code> — <strong>direct</strong>: read/write a fixed memory address.<br>
      <code>[Rn+off]</code> — <strong>indexed</strong>: memory at register + offset. Write <code>[Rn]</code> when offset is 0.</p>
    </section>

    <section>
      <h3>ALU Operations</h3>
      <p>One-operand syntax — <code>A</code> is always the implicit accumulator
      (both source and destination). All ALU ops set the <strong>Z</strong> (zero) flag.
      <code>ADD</code>/<code>SUB</code>/<code>CMP</code> also set <strong>C</strong> (carry);
      logic ops (<code>AND</code>/<code>OR</code>/<code>XOR</code>) clear it.</p>
<pre>ADD #10      ; A ← A + 10
SUB R0       ; A ← A − R0
AND #0x0F    ; A ← A &amp; 0x0F (mask low nibble)
OR  #0x80    ; A ← A | 0x80 (set high bit)
XOR #0xFF    ; A ← A ^ 0xFF (invert all bits)
CMP #0       ; set flags for A − 0, discard result</pre>
    </section>

    <section>
      <h3>Flags &amp; Comparisons</h3>
      <p><strong>Z</strong>=1 when result is zero.
      <strong>C</strong>=1 on unsigned overflow (ADD) or when A&nbsp;&ge;&nbsp;operand
      (SUB/CMP — uses 6502/ARM "no borrow" convention).
      Use <code>CMP</code> followed by a conditional branch:</p>
<pre>CMP #10      ; compare A against 10
BZ  equal    ; branch if A == 10
BNZ not_eq   ; branch if A != 10
BC  gte      ; branch if A &gt;= 10
BNC less     ; branch if A &lt; 10</pre>
    </section>

    <section>
      <h3>Jumps &amp; Branches</h3>
      <p><code>JMP addr</code> — absolute jump to any address.
      <code>BZ</code>/<code>BNZ</code>/<code>BC</code>/<code>BNC</code> — conditional
      branches. The assembler computes the PC-relative offset automatically
      when you use a label.</p>
<pre>loop:
    DEC R0
    BNZ loop     ; repeat until R0 is zero
    JMP done     ; then jump ahead</pre>
    </section>

    <section>
      <h3>Subroutines</h3>
      <p><code>CALL addr</code> pushes the return address onto the
      hardware stack and jumps to the target.
      <code>RET</code> pops the return address and resumes execution.
      The stack is shared with PUSH/POP (4 entries total — plan accordingly).</p>
<pre>    CALL my_func  ; call subroutine
    HLT
my_func:
    ST  A, [0xFF] ; do some work
    RET           ; return to caller</pre>
    </section>

    <section>
      <h3>Stack</h3>
      <p><code>PUSH A/R0/R1</code> saves a register onto the 4-entry hardware stack.
      <code>POP A/R0/R1</code> restores it (LIFO order). Commonly used to save/restore
      registers inside subroutines.</p>
<pre>my_func:
    PUSH R0       ; save R0
    LD   R0, #5   ; use R0 for local work
    ; ...
    POP  R0       ; restore original R0
    RET</pre>
    </section>

    <section>
      <h3>INC / DEC</h3>
      <p><code>INC A/R0/R1</code> and <code>DEC A/R0/R1</code> add or subtract 1.
      Wraps on overflow (255+1→0, 0−1→255).
      Sets the <strong>Z</strong> flag only — does <em>not</em> affect <strong>C</strong>,
      making them ideal for loop counters that shouldn't disturb carry state.</p>
<pre>    LD  R1, #3    ; loop 3 times
loop:
    ; ... loop body ...
    DEC R1
    BNZ loop      ; repeat until R1 is zero</pre>
    </section>

    <section>
      <h3>I/O &amp; Memory</h3>
      <p>256 bytes total: <code>0x00</code>–<code>0xFE</code> is RAM
      (code and data share the same space — von Neumann architecture).
      <code>0xFF</code> is the output port — writing a byte there sends it
      to external output. Execution starts at address <code>0x00</code>.</p>
<pre>.EQU IO, 0xFF
LD  A, #0x48    ; ASCII 'H'
ST  A, [IO]     ; prints "H"</pre>
    </section>

    <section>
      <h3>Directives</h3>
      <p><code>.EQU name, value</code> — define a named constant.<br>
      <code>.ORG addr</code> — set the next assembly address.<br>
      <code>.DB v1, v2, …</code> — emit raw data bytes.<br>
      <code>.DS "text"</code> — emit a null-terminated string
      (supports <code>\n</code> <code>\t</code> <code>\r</code> <code>\0</code> <code>\\</code> escapes).</p>
<pre>.EQU IO, 0xFF
msg:
    .DS "Hello!\n"  ; H,e,l,l,o,!,0x0A,0x00
data:
    .DB 1, 2, 0xFF  ; three raw bytes</pre>
    </section>

    <section>
      <h3>System</h3>
      <p><code>NOP</code> — no operation (does nothing, advances PC).
      <code>HLT</code> — halts the CPU. Every program should end with <code>HLT</code>
      to stop execution cleanly.</p>
    </section>
  </div>

  <!-- Code Editor -->
  <div class="panel">
    <div class="panel-header">
      <span>Assembly Editor</span>
      <span style="font-size:.7rem">Ctrl+Enter to run</span>
    </div>
    <div class="panel-body">
      <textarea id="code" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off">; hello.asm — Print "Hello world!" on the EDU-CPU
; Yes, there is an easier way to do this, but this example
; uses convoluted code to show you as much of the instruction
; set and assembler syntax as possible.
;
; Demonstrates: LD/ST, ADD, XOR, CMP, INC, DEC,
;   PUSH, POP, CALL, RET, JMP, BZ, BNZ, HLT,
;   immediate/register/direct/indexed addressing,
;   and .EQU, .DS, .DB directives.
;
; After running this code, try to write your own
; code to hunt for hidden treasure

    .EQU IO, 0xFF          ; I/O output port address

; --- Part 1: Print "Hello " with indexed addressing ---
start:
    LD  R0, #0              ; R0 = character index

print_hello:
    LD  A, [R0+hello_str]  ; Load char (indexed mode)
    CMP #0                  ; Null terminator?
    BZ  print_world         ; Yes — move on
    ST  A, [IO]             ; Output character (direct mode)
    INC R0                  ; Next character
    JMP print_hello

; --- Part 2: Print "world" by XOR-decoding ---
print_world:
    LD  R0, #0              ; Reset index
    LD  R1, #5              ; R1 = chars to decode

decode_loop:
    LD  A, [R0+xor_data]   ; Load encoded byte (indexed mode)
    XOR #0x55              ; Decode: original = encoded XOR key
    CALL print_char         ; Print via subroutine
    INC R0
    DEC R1                  ; Decrement counter
    BNZ decode_loop         ; Loop until done

; --- Part 3: Build '!' with register arithmetic ---
    LD  A, #0x11
    LD  R0, A               ; R0 ← A (register-to-register)
    LD  A, #0x10
    ADD R0                  ; A = 0x10 + 0x11 = 0x21 = '!'
    ST  A, [IO]

    LD  A, #0x0A            ; Newline
    ST  A, [IO]
    HLT

; --- Subroutine: output char in A, preserving regs ---
print_char:
    PUSH R0                 ; Save R0 on hardware stack
    PUSH R1                 ; Save R1
    ST   A, [IO]            ; Write to output port
    POP  R1                 ; Restore R1 (LIFO order)
    POP  R0                 ; Restore R0
    RET

; --- Data section ---
hello_str:
    .DS "Hello "            ; Null-terminated string

xor_data:
    ; "world" encoded with XOR 0x55
    ; w^0x55=0x22 o^0x55=0x3A r^0x55=0x27
    ; l^0x55=0x39 d^0x55=0x31
    .DB 0x22, 0x3A, 0x27, 0x39, 0x31
</textarea>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <button id="run-btn" onclick="runCode()">Run</button>
    <label class="check">
      <input type="checkbox" id="trace"> Enable trace
    </label>
    <span class="status" id="status"></span>
  </div>

  <!-- Errors -->
  <div class="errors" id="errors"></div>

  <!-- Assembly Listing -->
  <div class="panel" id="listing-panel" style="display:none">
    <div class="panel-header"><span>Assembly Listing</span></div>
    <div class="panel-body">
      <div class="output" id="listing"></div>
    </div>
  </div>

  <!-- Stdout / Stderr -->
  <div class="output-row">
    <div class="panel">
      <div class="panel-header"><span>Output (stdout)</span></div>
      <div class="panel-body">
        <div class="output stdout" id="stdout"></div>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"><span>Trace / Errors (stderr)</span></div>
      <div class="panel-body">
        <div class="output stderr" id="stderr"></div>
      </div>
    </div>
  </div>
</div>

<script>
const $code    = document.getElementById('code');
const $trace   = document.getElementById('trace');
const $btn     = document.getElementById('run-btn');
const $status  = document.getElementById('status');
const $errors  = document.getElementById('errors');
const $listing = document.getElementById('listing');
const $listPnl = document.getElementById('listing-panel');
const $stdout  = document.getElementById('stdout');
const $stderr  = document.getElementById('stderr');

// Ctrl+Enter shortcut
$code.addEventListener('keydown', e => {
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    runCode();
  }
  // Tab inserts spaces
  if (e.key === 'Tab') {
    e.preventDefault();
    const s = $code.selectionStart, end = $code.selectionEnd;
    $code.value = $code.value.substring(0, s) + '    ' + $code.value.substring(end);
    $code.selectionStart = $code.selectionEnd = s + 4;
  }
});

async function runCode() {
  $btn.disabled = true;
  $status.textContent = 'Assembling\u2026';
  $status.className = 'status';
  $errors.classList.remove('visible');
  $errors.textContent = '';
  $listing.textContent = '';
  $listPnl.style.display = 'none';
  $stdout.textContent = '';
  $stderr.textContent = '';

  try {
    const resp = await fetch('/api/run', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        code:  $code.value,
        trace: $trace.checked,
      }),
    });
    const r = await resp.json();

    if (r.listing) {
      $listing.textContent = r.listing;
      $listPnl.style.display = '';
    }
    $stdout.textContent = r.stdout || '';
    $stderr.textContent = r.stderr || '';

    if (!r.success) {
      $errors.textContent = r.errors.join('\n');
      $errors.classList.add('visible');
      $status.textContent = 'Assembly failed';
      $status.className = 'status err';
    } else {
      const tag = r.exit_code === 0 ? 'ok' : 'err';
      $status.textContent = `Done \u2014 ${r.cycles} cycles (exit ${r.exit_code})`;
      $status.className = 'status ' + tag;
    }
  } catch (err) {
    $errors.textContent = 'Request failed: ' + err.message;
    $errors.classList.add('visible');
    $status.textContent = 'Error';
    $status.className = 'status err';
  } finally {
    $btn.disabled = false;
  }
}
</script>
</body>
</html>
